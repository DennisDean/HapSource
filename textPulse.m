classdef textPulse
%textPulse A class for developing a text representation of a pulse
%   The text description of hormone pulsatility is developed to
%   represent the production tree generated by the context free
%   language representation of hormone pulsatility. The CFL is the
%   functional component of the Hierarchally Adaptive Partitioing
%   Algorithm.
%
%   Initially, the thought was to have a text representation. I decided
%   to create a class after reviewing the potential uses for the
%   representation
%
%   Potential Uses: (1) text representation of time series, (2) basis
%   for identifiing subgroups, (3) basis for identifying point process
%   secretion probabilities, (4) basis for identifying impulse
%   functions, (5) Basis for creating visualization of quantitative
%   information computed within group.
%
%   Developer: Dennis A. Dean, II
%
%   Groups: Neuroscience Statistical Research Laboratory, MGH, MIT, HMS
%           Analytics and Modeling Unit, BWH, HMS
%
%   Date: 2010-10-06
%
%   Things to do:
%     (1) Need to add starting times and concentrations inorder to
%         identify pre and post paritioing conditions.
%
% File is part of the HAP analysis program
%
% The methods are described in detail in:
%
% Dean II, D. A. (2011) Integrating Formal Language Theory with Mathematical 
% Modeling to Solve Computational Issues in Sleep and Circadian Applications 
% [dissertation]. University of Massachusetts. 239 p.
%
%
% Informatician: Dennis A. Dean, II, Ph.D 
%
% Divison of Sleep Medicine
% Brigham and Women's Hospital
% Harvard Medical School
% 221 Longwood Ave
% Boston, MA  02149
%
% Release: 0.8 Beta
%
% Copyright © [2012] The Brigham and Women's Hospital, Inc. THE BRIGHAM AND 
% WOMEN'S HOSPITAL, INC. AND ITS AGENTS RETAIN ALL RIGHTS TO THIS SOFTWARE 
% AND ARE MAKING THE SOFTWARE AVAILABLE ONLY FOR SCIENTIFIC RESEARCH 
% PURPOSES. THE SOFTWARE SHALL NOT BE USED FOR ANY OTHER PURPOSES, AND IS
% BEING MADE AVAILABLE WITHOUT WARRANTY OF ANY KIND, EXPRESSED OR IMPLIED, 
% INCLUDING BUT NOT LIMITED TO IMPLIED WARRANTIES OF MERCHANTABILITY AND 
% FITNESS FOR A PARTICULAR PURPOSE. THE BRIGHAM AND WOMEN'S HOSPITAL, INC. 
% AND ITS AGENTS SHALL NOT BE LIABLE FOR ANY CLAIMS, LIABILITIES, OR LOSSES 
% RELATING TO OR ARISING FROM ANY USE OF THIS SOFTWARE.
%    
    
    %-------------------------------------------------- Constant Properties
    properties (Constant)
        % Define nomenclature for text based representation of hormone
        % time series
        PULSE_START_CHAR = '(';
        PULSE_END_CHAR = ')';
        PULSE_PEAK_CHAR = ':'
        DECREASING_SEGMENT_CHAR = '>';
        INCREASING_SEGMENT_CHAR = '<';
        FLAT_SEGMENT_CHAR = '-'; 
        
        % Event description
        EVENT_TYPES = {'PRIOR_EVENT', 'PULSE_START', 'PULSE_PEAK', ...
            'PULSE_END','POST_EVENT'};
        PRIOR_EVENT_VAL = 1;
        PULSE_START_VAL = 2;
        PULSE_PEAK_VAL = 3;
        PULSE_END_VAL = 4;
        POST_EVENT_VAL = 5;   
        
        % Output format
        LATEX_EQUATION_TYPE = {'MATLAB','MATHTYPE'};
    end
    %---------------------------------------------------- Public Properties
    properties
        % define inputs from pulseSegmentation Class.
        %
        %   hormone_plot: data and demongraphic information required for
        %       display
        %
        %   recursion_summary_results_struct_array: Contains summary
        %       information
        %
        
        % Class Input
        hormone_plot
        recursion_summary_results_struct_array;
        
        % Output parameters
        show_recursive_peaks = 0;
        show_terminal_peak = 0;
        show_recursion_inputs;
        show_intermediate_recursion_results;
        show_recursion_results;
        show_latex = 0;
        
        % Equations output
        latex_type = 'MATHTYPE';
    end
    %--------------------------------------------------- Private Properties
    properties (Access = private)
        % Private properties to control the algorithmn
        %
        %    TIME_SORT_EPSILON: starting recursion level
        %
        %    text_pulse_struct: a structure that assoicates each character
        %       in the text representation with numeric values (time, pulse
        %       parameters, closing/opening paren.
        %
    
        % algorithmn constant
        TIME_SORT_EPSILON = 0.1 % assume minutes, should work for hours;
        START_RECURSION_VALUE = 5 % assume no values used = or above
        
        % Output constant
        PRN_LEVEL = 1; % set default to simplest description
        
        % Internal Options
        GLOBAL_DEBUG_FLAG = 0;
        SHOW_RECURSION_INPUTS = 0; 
        SHOW_INTERMEDIATE_RECURSION_RESULTS = 0; 
        SHOW_RECURSION_RESULTS = 0; 
        USE_TMAX = 0;
        TMAX;
    end
    %------------------------------------------------- Dependent Properties
    properties (Dependent)
        % Properties derrived from pulseSegmentation class are used to
        % generate concise reprsentation of hormone pulsatility
        %
        %    text_pulse_str: a text summary of the concentration profile
        %
        %    text_pulse_struct: a structure that assoicates each character
        %       in the text representation with numeric values (time, pulse
        %       parameters, closing/opening paren.
        %
        
        % Input Properties
        num_recursions;
        
        % Primary Class Output
        text_pulse_str;
        text_pulse_struct;
        
        % Output Value Properties
        prn_precision;
        prn_level;
        
        % Pretty output
        latex_pulse_str
    end
    %------------------------------------------------------- Public Methods
    methods
        %------------------------------------------------------ constructor
        function obj = textPulse(varargin)
            % getPeaks constructor is used to define the object. If only
            % only column of data is added then
            
            % Function constants
            LOCAL_DEBUG_FLAG = 0;
            
            % Process object creation input
            if nargin == 2
                % Process two entries
                obj.hormone_plot = varargin{1};
                obj.recursion_summary_results_struct_array = varargin{2};
                obj.TMAX = max(obj.hormone_plot.t);
            elseif nargin == 3
                % Proces three entries
                obj.hormone_plot = varargin{1};
                obj.recursion_summary_results_struct_array = varargin{2};
                obj.TMAX = varargin{3}; 
                obj.USE_TMAX = 1;
            else
                fprintf('--- textPulse(hormone_plot,recursion_summary_results_struct_array)\n');
                error('function prototype not found');
            end
            
            % Echo input to console
            if obj.or_list(LOCAL_DEBUG_FLAG, obj.GLOBAL_DEBUG_FLAG)
                echo_input_to_console(obj)
            end
            
            % Currently no setup is required
            % Use methods for generating string representations.
        end    
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Dependent Properties
        %------------------------------------------------------- num points
        function num_recursions = get.num_recursions(obj)
            %num_recursions get number of recursions from input
            num_recursions = length(obj.recursion_summary_results_struct_array);
        end
        %--------------------------------------------------- text_pulse_str
        function text_pulse_str = get.text_pulse_str(obj)
            % function uses text_pulse_struct to generate a text
            % representation of hormone pulsatility
            %
            
            % Function constant
            LOCAL_DEBUG_FLAG = 0;
            
            % Process object input
            text_pulse_struct = obj.text_pulse_struct;
            num_points = length(text_pulse_struct);
            
            % text_pulse_str
            for s = 1:num_points
                text_pulse_struct(s).event_char;
                text_pulse_str(s) = text_pulse_struct(s).event_char;
            end
            
            % write sort_times
            if LOCAL_DEBUG_FLAG == 1
               disp(text_pulse_str) 
                
               get_sort_times_F = @(x)eval(sprintf('text_pulse_struct(%d).%s',x,'sort_time'));
               obj.display_vector(arrayfun(get_sort_times_F, [1:num_points]),obj.prn_precision);

               get_sort_times_F = @(x)eval(sprintf('text_pulse_struct(%d).%s',x,'event_t'));
               obj.display_vector(arrayfun(get_sort_times_F, [1:num_points]),obj.prn_precision);
            end
        end
        %-------------------------------------------------- latex_pulse_str
        function latex_pulse_str = get.latex_pulse_str(obj)
            %latex_pulse_str function returns a pulse string suitable for
            % use in math type
            
            % Function constant
            LOCAL_DEBUG_FLAG = 0;
            
            % Latex structure         
            PAREN_START = '\overline{\left(';
            PAREN_START_END  = '\left({}\right)';
            PAREN_END = '\right)}';
            switch  obj.latex_type
                case 'MATLAB'
                    EQ_START_STR = '$$';
                    EQ_END_STR = '$$'; 
                case 'MATHTYPE'
                    EQ_START_STR = '\[';
                    EQ_END_STR = '\]'; 
                otherwise
                    EQ_START_STR = '\[';
                    EQ_END_STR = '\]';                  
            end
            plot_equation = 1;
        
            % Process object input
            text_pulse_str = obj.text_pulse_str;
            num_chars = length(text_pulse_str);

            % Create latex string
            latex_pulse_str = EQ_START_STR;
            c = 1;
            while  c <= num_chars
                e = text_pulse_str(c);    
                switch e
                    case {'('}
                        % Get look ahead characters
                        e2 = text_pulse_str(c+1); 
                        if c+2<= num_chars
                            e3 = text_pulse_str(c+2);
                        else
                            e3 = '';
                        end
                        
                        % Set latex entry based on look ahead characters
                        if e2 == ')'
                            latex_pulse_str = strcat(latex_pulse_str,...
                                PAREN_START_END);
                            c = c+1;
                        elseif and(e3 == ')',e2~='(')
                             a_str = sprintf('\\left(%s\\right)',e2);
                             latex_pulse_str = strcat(latex_pulse_str,...
                                a_str);
                             c = c+2;  
                        else
                            latex_pulse_str = strcat(latex_pulse_str,...
                                PAREN_START);
                        end
                    case {')'}
                        latex_pulse_str = strcat(latex_pulse_str,PAREN_END);
                    case {'<','>',':'}
                        latex_pulse_str = strcat(latex_pulse_str,e);
                    otherwise
                        latex_pulse_str = strcat(latex_pulse_str,e);  
                end
                c = c+1;
            end
            latex_pulse_str = strcat(latex_pulse_str,EQ_END_STR);
            
            if obj.show_latex == 1
                disp(latex_pulse_str)
            end
            
            % write sort_times
            if LOCAL_DEBUG_FLAG == 1
                latex_pulse_str
            end
        end
        %---------------------------------------------- create_latex_figure
        function latex_fig_id = create_latex_figure(obj)
            % Write input to screen
            
            % Function constant
            LOCAL_DEBUG_FLAG = 0;
            percent_of_length = 0.05;
            max_font = 200;
            window_height = 100;
            window_width = 100;
            font_size = 10 ;
            font_increment = 2;
            figure_increment = 10;
            height_test = 0.36;
            width_test = 0.15;
            
            % Get latex string to print
            start_latex_type = obj.latex_type;
            obj.latex_type = 'MATLAB';
            matlab_latex_str = obj.latex_pulse_str;
            
            % Create figure
            latex_fig_id = figure();
            v = axis();
            h = text(mean(v(1:2)), mean(v(3:4)), matlab_latex_str, ...
                'FontUnits','Points','Interpreter', 'latex', 'VerticalAlignment', 'middle',...
                'HorizontalAlignment', 'center', 'FontSize', font_size);
            
            % Determine figure proportions to determine range
            text_box_extent = get(h,'extent');
            figure_position = get(latex_fig_id, 'Position');
            set(latex_fig_id,'Position',[figure_position(1:2) window_width window_height ]);
            
            % Iterate font size to mazimize height is window
            test = ones(1,1);
            while test == ones(1,1)
                % while text exten is within the bounds of the axis area
                text_size = get(text('interpreter', 'latex', 'string', matlab_latex_str,...
                    'position', [.5 .5], 'HorizontalAlignment','Center',...
                    'Units','Normalized','FontSize',...
                    font_size),'extent');
                
                % Check extend bounds
                test = text_size(2) > height_test;
                
                % Increment font size
                font_size = font_size + font_increment;
            end
            
            % Reset Figure
            figure(latex_fig_id)
            clf;
            axis off
            a = text('interpreter', 'latex', 'string',matlab_latex_str,'position', [.5 .5], ....
                'HorizontalAlignment','Center','Units','Normalized','FontSize', font_size-2);
            figure_position = get(latex_fig_id, 'Position');
            text_extent = get(a, 'extent');
            ratio = text_extent(3)/text_extent(4);
            
            % Iterate window width
            figure_width = figure_position(3);
            test = ones(1,1);
            iter = 1;
            iter_max = 50;
            while and(test == ones(1,1), iter <= iter_max)
                % set figure position
                set(latex_fig_id, 'Position', ...
                    [figure_position(1:2) figure_width figure_position(4)]);
                figure(latex_fig_id);
                
                % while text exten is within the bounds of the axis area
                text_size = get(text('interpreter', 'latex', 'string', matlab_latex_str,...
                    'position', [.5 .5], 'HorizontalAlignment','Center',...
                    'Units','Normalized', 'FontSize', font_size),'extent');
                
                % Check extend bounds
                test = text_size(1) < - width_test;
                
                % Increment font size
                figure_width = figure_width + ceil(figure_increment*ratio);
                iter = iter+1;
            end
            
            % redraw figure
            figure(latex_fig_id)
            clf;
            axis off
            text('interpreter', 'latex', 'string',matlab_latex_str,'position', [.5 .5], ....
                'HorizontalAlignment','Center','Units','Normalized','FontSize', font_size-2);
            figure_position = get(latex_fig_id, 'Position');
            
            % REturn to starting type
            obj.latex_type = start_latex_type;
        end        
        %------------------------------------------------------- echo_input
        function echo_input_to_console(obj)
            % Write input to screen
            
            % Function constant
            LOCAL_DEBUG_FLAG = 0;
            
            % echo output to console
            fprintf('------------------------------------------------ textPeak Input\n');
            fprintf('---------------------------------------------------------------\n');
            fprintf('hormone_plot\n');
            disp(obj.hormone_plot);
            fprintf('recursion_summary_results_struct_array\n');
            disp(obj.recursion_summary_results_struct_array);
            fprintf('t max\n');
            disp(obj.TMAX);
            fprintf('---------------------------------------------------------------\n');
        end
        %--------------------------------------------------- prn_preceision
        function prn_precision = get.prn_precision(obj)
            % Set print precison so that difference in sort time can be
            % seen when displayed.  User is not allowed to set
            % prn_precision
            
            % Function constant
            LOCAL_DEBUG_FLAG = 0;
            
            % The organized
            prn_precision = obj.num_recursions+1;

            if LOCAL_DEBUG_FLAG == 1
                fprintf('------------------------------------- epsilon\n');
                prn_precision
                fprintf('---------------------------------------------\n');
            end
        end
        %--------------------------------------------------- get_prn_level
        function prn_level = get.prn_level(obj)
            %char_time_offset the recurrsion level 
            
            % Function constant
            LOCAL_DEBUG_FLAG = 0;
            
            % The organized
            prn_level = obj.PRN_LEVEL;

            if LOCAL_DEBUG_FLAG == 1
                fprintf('------------------------------------- epsilon\n');
                prn_precision
                fprintf('---------------------------------------------\n');
            end
        end
        %-------------------------------------------------- set_prn_level
        function obj = set.prn_level(obj, val)
            %char_time_offset the recurrsion level 
            
            % Function constant
            LOCAL_DEBUG_FLAG = 0;
            
            % The organized
            if and( val>= 1, val <= obj.num_recursions)
                % Vallid entry
                obj.PRN_LEVEL = val;
            else
                % Ignore invallid entry
                fprintf('%%%%------------ invallid print level, entry ignored\n');
            end

            if LOCAL_DEBUG_FLAG == 1
                fprintf('------------------------------------- epsilon\n');
                prn_precision
                fprintf('---------------------------------------------\n');
            end
        end
         %------------------------------------------- show_recursion_inputs
        function show_recursion_inputs = get.show_recursion_inputs(obj)
            %char_time_offset the recurrsion level 
            
            % Function constant
            LOCAL_DEBUG_FLAG = 0;
            
            % The organized
            show_recursion_inputs = obj.SHOW_RECURSION_INPUTS;

            if LOCAL_DEBUG_FLAG == 1
                fprintf('---------------------  show_recursion_INPUTSs\n');
                disp(SHOW_RECURSION_INPUTS)
                fprintf('---------------------------------------------\n');
            end
        end
        %-------------------------- set show_intermeidate_recursion_results
        function obj = set.show_intermediate_recursion_results(obj, val)
            %char_time_offset the recurrsion level 
            
            % Function constant
            LOCAL_DEBUG_FLAG = 0;
            
            % The organized
            if or( val>= 0, val <= 1)
                % Vallid entry
                obj.SHOW_INTERMEDIATE_RECURSION_RESULTS = val;
            else
                % Ignore invallid entry
                fprintf('%%%%------------ invallid show_intermeidate_recursion_inputs, entry ignored\n');
            end

            if LOCAL_DEBUG_FLAG == 1
                fprintf('--------- show_intermeidate_recursion_results\n');
                obj.SHOW_INTERMEDIATE_RECURSION_RESULTS
                fprintf('---------------------------------------------\n');
            end
        end
        %------------------------------- show_intermeidate_recursion_inputs
        function show_intermediate_recursion_results = ...
                get.show_intermediate_recursion_results(obj)
            %char_time_offset the recurrsion level 
            
            % Function constant
            LOCAL_DEBUG_FLAG = 0;
            
            % The organized
            show_intermediate_recursion_results = ...
                obj.show_intermediate_recursion_results;

            if LOCAL_DEBUG_FLAG == 1
                fprintf('---------------------  show_recursion_results\n');
                disp(show_intermediate_recursion_results)
                fprintf('---------------------------------------------\n');
            end
        end
        %---------------------------------------- set show_recursion_inputs
        function obj = set.show_recursion_inputs(obj, val)
            %char_time_offset the recurrsion level 
            
            % Function constant
            LOCAL_DEBUG_FLAG = 0;
            
            % The organized
            if or( val>= 0, val <= 1)
                % Vallid entry
                obj.SHOW_RECURSION_INPUTS = val;
            else
                % Ignore invallid entry
                fprintf('%%%%------------ invallid show_recursion_inputs, entry ignored\n');
            end

            if LOCAL_DEBUG_FLAG == 1
                fprintf('------------------------------------- epsilon\n');
                prn_precision
                fprintf('---------------------------------------------\n');
            end
        end
        %------------------------------------------ show_recursion_results
        function show_recursion_results = get.show_recursion_results(obj)
            %char_time_offset the recurrsion level 
            
            % Function constant
            LOCAL_DEBUG_FLAG = 0;
            
            % The organized
            show_recursion_results = obj.SHOW_RECURSION_RESULTS;

            if LOCAL_DEBUG_FLAG == 1
                fprintf('---------------------  show_recursion_results\n');
                disp(show_recursion_results)
                fprintf('---------------------------------------------\n');
            end
        end
        %--------------------------------------- set show_recursion_results
        function obj = set.show_recursion_results(obj, val)
            %char_time_offset the recurrsion level 
            
            % Function constant
            LOCAL_DEBUG_FLAG = 0;
            
            % The organized
            if or( val>= 0, val <= 1)
                % Vallid entry
                obj.SHOW_RECURSION_RESULTS = val;
            else
                % Ignore invallid entry
                fprintf('%%%%------------ invallid show_recursion_results, entry ignored\n');
            end

            if LOCAL_DEBUG_FLAG == 1
                fprintf('------------------------------------- epsilon\n');
                prn_precision
                fprintf('---------------------------------------------\n');
            end
        end
        %------------------------------------------------ text_pulse_struct
        function text_pulse_struct = get.text_pulse_struct(obj)
            %text_pulse_struct recursion cell array is restructed to a
            % structure array of characters assoiciated with timimg and
            % pharmakokinetic information.
            %
            
            % Local debug flag
            LOCAL_DEBUG_FLAG = 0;
            
            % Define text_pulse_struct
            text_pulse_struct = struct ('event_char', '',...
                'event_type', '', ...
                'event_t', [], ...
                'recursion_level', NaN,...
                'sort_time', NaN,...
                'secretion_rate', NaN, ...
                'cleareance_rate',NaN, ...
                'interpulse_interval', NaN,...
                'associated_event_types', {},...
                'associated_event_times', []);
            
            % Define function values
            next_entry = 1;
            num_recursions = length(...
                obj.recursion_summary_results_struct_array);
            current_recursion = obj.num_recursions - num_recursions+1;
            
            % Analyze terminal recursion
            num_recursions = obj.num_recursions;
            terminal_recursion_summary_struct = ...
                obj.recursion_summary_results_struct_array{num_recursions};
            num_points = terminal_recursion_summary_struct.num_points;
            are_extended_peaks_and_valleys_proper = ...
                terminal_recursion_summary_struct.are_extended_peaks_and_valleys_proper;
            
            % Set sort time offset
            offset = char_time_offset(obj, 1);
            e = epsilon(obj, 1);
            
            % Echo information about terminal structure
            if obj.show_recursion_inputs
                 echo_input_to_console(obj)
            end
                
            if LOCAL_DEBUG_FLAG == 1
                fprintf('----------------------------------------- terminal recurse struct\n');
                % terminal_recursion_summary_struct
                fprintf('Y:\n');
                obj.display_vector(terminal_recursion_summary_struct.Y,obj.prn_precision);
                fprintf('t:\n');
                obj.display_vector(terminal_recursion_summary_struct.t,obj.prn_precision); 
            end
                                    
            % check termination condition
            if are_extended_peaks_and_valleys_proper == 0
                % if extended peaks and valleys are not proper then the segments
                % are either rising or falling. 
                % terminal condition is either rising or falling
                
                %------------------------------------ process pre condition
                recursion_t = terminal_recursion_summary_struct.t;
                recursion_Y = terminal_recursion_summary_struct.Y;               
                t = obj.hormone_plot.t;
                Y = obj.hormone_plot.Y;
                data_indexes = find(t<=obj.TMAX);
                t = obj.hormone_plot.t(data_indexes);
                Y = obj.hormone_plot.Y(data_indexes);
                
                prior_indexes = find(recursion_t(1) > t);
                post_indexes = find(recursion_t(end) < t);
                
                % check if a precharacter is required
                if ~isempty(prior_indexes)
                    % starting condition found
                    prior_Y = Y(prior_indexes);
                    prior_t = t(prior_indexes);
                    
                    % determine pre- case
                    if Y(1)>recursion_Y(1)
                        text_pulse_struct(next_entry).event_char = ...
                            obj.DECREASING_SEGMENT_CHAR;
                    else
                        text_pulse_struct(next_entry).event_char = ...
                            obj.INCREASING_SEGMENT_CHAR;
                    end
                             
                    % Define sturcture properties
                    text_pulse_struct(next_entry).recursion_level = ...
                        num_recursions;
                    text_pulse_struct(next_entry).event_type = ...
                        obj.EVENT_TYPES{obj.PRIOR_EVENT_VAL};
                    text_pulse_struct(next_entry).event_t = recursion_t(1);
                    text_pulse_struct(next_entry).sort_time = ...
                        double(recursion_t(1))- offset - 2*e;
                    text_pulse_struct(next_entry).secretion_rate = NaN;
                    text_pulse_struct(next_entry).cleareance_rate = NaN;
                    text_pulse_struct(next_entry).interpulse_interval = NaN;
                    text_pulse_struct(next_entry).associated_event_types = {};
                    text_pulse_struct(next_entry).associated_event_times = [];
                    
                    % prepare for next entry
                    next_entry = next_entry + 1;
                end
                %----------------------------- process recursion information
                % Add start segment
                text_pulse_struct(next_entry).event_char = ...
                    obj.PULSE_START_CHAR;
                text_pulse_struct(next_entry).recursion_level = ...
                    num_recursions;
                text_pulse_struct(next_entry).event_type = ...
                    obj.EVENT_TYPES{obj.PULSE_START_VAL};
                text_pulse_struct(next_entry).event_t = recursion_t(1);
                text_pulse_struct(next_entry).sort_time = ...
                    double(double(recursion_t(1)) + offset + 2*e);
                text_pulse_struct(next_entry).secretion_rate = NaN;
                text_pulse_struct(next_entry).cleareance_rate = NaN;
                text_pulse_struct(next_entry).interpulse_interval = NaN;
                text_pulse_struct(next_entry).associated_event_types = {};
                text_pulse_struct(next_entry).associated_event_times = [];
                next_entry = next_entry + 1;
                
                
                % Add end segment
                text_pulse_struct(next_entry).event_char = ...
                    obj.PULSE_END_CHAR;
                text_pulse_struct(next_entry).recursion_level = ...
                    num_recursions;
                text_pulse_struct(next_entry).event_type = ...
                    obj.EVENT_TYPES{obj.PULSE_END_VAL};
                text_pulse_struct(next_entry).event_t = recursion_t(end);
                text_pulse_struct(next_entry).sort_time = ...
                    double(double(recursion_t(end)) - offset - 2*e);
                text_pulse_struct(next_entry).secretion_rate = NaN;
                text_pulse_struct(next_entry).cleareance_rate = NaN;
                text_pulse_struct(next_entry).interpulse_interval = NaN;
                text_pulse_struct(next_entry).associated_event_types = {};
                text_pulse_struct(next_entry).associated_event_times = [];
                next_entry = next_entry + 1;
                
                %----------------------------- Add high point if it exists
                
                if obj.show_terminal_peak
                    if recursion_t(1)>recursion_t(end)
                        % peak symbol at start
                        text_pulse_struct(next_entry).event_char = ...
                            obj.PULSE_PEAK_CHAR;
                        text_pulse_struct(next_entry).recursion_level = ...
                            num_recursions;
                        text_pulse_struct(next_entry).event_type = ...
                            obj.EVENT_TYPES{obj.PULSE_END_VAL};
                        text_pulse_struct(next_entry).event_t = recursion_t(1);
                        text_pulse_struct(next_entry).sort_time = ...
                            double(double(recursion_t(1)) - offset - e);
                        text_pulse_struct(next_entry).secretion_rate = NaN;
                        text_pulse_struct(next_entry).cleareance_rate = NaN;
                        text_pulse_struct(next_entry).interpulse_interval = NaN;
                        text_pulse_struct(next_entry).associated_event_types = {};
                        text_pulse_struct(next_entry).associated_event_times = [];
                        next_entry = next_entry + 1;
                        
                        % Define terminal condition
                        base_condition_char = obj.DECREASING_SEGMENT_CHAR;
                    elseif recursion_t(1)< recursion_t(end)
                        % add peak symbol at end
                        % Add end segment
                        % Add start segment
                        text_pulse_struct(next_entry).event_char = ...
                            obj.PULSE_PEAK_CHAR;
                        text_pulse_struct(next_entry).recursion_level = ...
                            num_recursions;
                        text_pulse_struct(next_entry).event_type = ...
                            obj.EVENT_TYPES{obj.PULSE_END_VAL};
                        text_pulse_struct(next_entry).event_t = recursion_t(end);
                        text_pulse_struct(next_entry).sort_time = ...
                            double(double(recursion_t(end)) + offset + e);
                        text_pulse_struct(next_entry).secretion_rate = NaN;
                        text_pulse_struct(next_entry).cleareance_rate = NaN;
                        text_pulse_struct(next_entry).interpulse_interval = NaN;
                        text_pulse_struct(next_entry).associated_event_types = {};
                        text_pulse_struct(next_entry).associated_event_times = [];
                        next_entry = next_entry + 1;
                                                         
                        % Define terminal condition
                        base_condition_char = obj.INCREASING_SEGMENT_CHAR;
                    else
                        % don't symbol if starting and ending value is the same
                        
                    end
                else
                    % Set center character if rise character not set
                    if recursion_t(1)>recursion_t(end)
                        % Define terminal condition
                        base_condition_char = obj.DECREASING_SEGMENT_CHAR;
                    elseif recursion_t(1)< recursion_t(end)    
                        % Define terminal condition
                        base_condition_char = obj.INCREASING_SEGMENT_CHAR; 
                    end
                    
                    %-------------------Add base_condition_char if required
                    if obj.prn_level == 1
                        text_pulse_struct(next_entry).event_char = ...
                            base_condition_char;
                        text_pulse_struct(next_entry).recursion_level = ...
                            num_recursions;
                        text_pulse_struct(next_entry).event_type = ...
                            obj.EVENT_TYPES{obj.PULSE_END_VAL};
                        text_pulse_struct(next_entry).event_t = ...
                            (recursion_t(1)+recursion_t(end))/2;
                        text_pulse_struct(next_entry).sort_time = ...
                            double((recursion_t(1)+recursion_t(end))/2);
                        text_pulse_struct(next_entry).secretion_rate = NaN;
                        text_pulse_struct(next_entry).cleareance_rate = NaN;
                        text_pulse_struct(next_entry).interpulse_interval = NaN;
                        text_pulse_struct(next_entry).associated_event_types = {};
                        text_pulse_struct(next_entry).associated_event_times = [];
                        next_entry = next_entry + 1;  
                    end
                end
                %------------------------------------ process post condition
                % check if a post character is required
                if ~isempty(post_indexes)
                    % ending condition found
                    post_Y = Y(post_indexes);
                    post_t = t(post_indexes);
                    
                    % determine pre- case
                    if Y(end)>recursion_Y(end)
                        text_pulse_struct(next_entry).event_char = ...
                            obj.INCREASING_SEGMENT_CHAR;
                    else
                        text_pulse_struct(next_entry).event_char = ...
                            obj.DECREASING_SEGMENT_CHAR;
                    end
                    
                    % Define sturcture properties
                    text_pulse_struct(next_entry).recursion_level = ...
                        num_recursions;
                    text_pulse_struct(next_entry).event_type = ...
                        obj.EVENT_TYPES{obj.POST_EVENT_VAL};
                    text_pulse_struct(next_entry).event_t = recursion_t(end);
                    text_pulse_struct(next_entry).sort_time = ...
                        double(double(recursion_t(end)) + offset + 2*e);
                    text_pulse_struct(next_entry).secretion_rate = NaN;
                    text_pulse_struct(next_entry).cleareance_rate = NaN;
                    text_pulse_struct(next_entry).interpulse_interval = NaN;
                    text_pulse_struct(next_entry).associated_event_types = {};
                    text_pulse_struct(next_entry).associated_event_times = [];
                    
                    % prepare for next entry
                    next_entry = next_entry+ 1;
                end
                
                % Save structure in order to enable print
                text_pulse_struct1 = text_pulse_struct;
                
                %-----------------------------------------Process next level
                return_struct_vallid = 0;
                if obj.prn_level > 1
                    [recursed_text_pulse_struct return_struct_vallid  ] = ...
                        process_recursion_array...
                        (obj, obj.recursion_summary_results_struct_array(1:end-1));
                    
                    % Merge if return stuc 
                    if return_struct_vallid                        
                        % Merge and sort stuct
                        text_pulse_struct = merge_sort_struct (obj, ...
                            text_pulse_struct1, recursed_text_pulse_struct,...
                            'sort_time' );
                    end
                end
                
                %---------------------------------- Echo results to console
                if and(obj.or_list(LOCAL_DEBUG_FLAG, ...
                        obj.GLOBAL_DEBUG_FLAG,...
                        obj.show_recursion_results), ...
                        obj.prn_level == 1)
                    % echo text summary and time for first level only
                    obj.prn_recursion_summary(text_pulse_struct1, ...
                        current_recursion);
                    % Echo results to console
                elseif obj.and_list(obj.or_list(LOCAL_DEBUG_FLAG, ...
                        obj.GLOBAL_DEBUG_FLAG,...
                        obj.show_recursion_results),...
                        return_struct_vallid,...
                        ~obj.show_intermediate_recursion_results)
                    % echo text summary and time for first level and
                    % recursion return
                    obj.prn_recursion_summary(text_pulse_struct1, ...
                        current_recursion, recursed_text_pulse_struct);
                elseif obj.and_list(obj.or_list(LOCAL_DEBUG_FLAG, ...
                            obj.GLOBAL_DEBUG_FLAG,...
                            obj.show_recursion_results),...
                        return_struct_vallid,...
                        ~obj.show_intermediate_recursion_results)
                    % echo text summary and time for first level,
                    % recursion return, and merged value
                    obj.prn_recursion_summary(text_pulse_struct, ...
                        current_recursion);
                elseif obj.and_list(obj.or_list(LOCAL_DEBUG_FLAG, ...
                        	obj.GLOBAL_DEBUG_FLAG,...
                            obj.show_recursion_results),...
                        obj.show_intermediate_recursion_results,...
                        return_struct_vallid)
                    % echo text summary and time for first level,
                    % recursion return, and merged value
                    obj.prn_recursion_summary(text_pulse_struct1, ...
                        current_recursion);
                    obj.prn_recursion_summary(text_pulse_struct, ...
                        current_recursion, recursed_text_pulse_struct);
                    obj.prn_recursion_summary(text_pulse_struct, ...
                        current_recursion);                    
                end
            else
                % are_extended_peaks_and_valleys_proper is proper
                error('Unexpected termination condition');
            end
            % Sort structure entries
            sfield = 'sort_time';
            text_pulse_struct = obj.sort_struct(text_pulse_struct,sfield );
        end
    end
    %------------------------------------------------------ Private Methods
    methods (Access = protected)
        %------------------------------------------------------- num points
        function [text_pulse_struct vallid ] = process_recursion_array...
                (obj, recurrsion_array)
            % Function is used to process each entry recursively. The
            % return struct is merged on the return
            %
            
            % Function constants
            LOCAL_DEBUG_FLAG = 0;
            
            % Define text_pulse_struct
            text_pulse_struct = struct ('event_char', '',...
                'event_type', '', ...
                'recursion_level', NaN,...
                'sort_time', NaN,...
                'secretion_rate', NaN, ...
                'cleareance_rate',NaN, ...
                'interpulse_interval', NaN,...
                'associated_event_types', {},...
                'associated_event_times', []);
            
            % Define function values
            num_recursions = length(recurrsion_array);
            next_entry = 1;
            current_recursion = obj.num_recursions - num_recursions+1;

            % Set sort time offset
            offset = char_time_offset(obj, current_recursion);
            e = epsilon(obj, current_recursion);
            
            % Evaluate recurssion array
            if isempty(recurrsion_array)
                % Terminal condition
                text_pulse_struct = struct();
                vallid = 0;
            else
                % Process current entry
                current_struct = recurrsion_array{end};
                
                %-------------------------------------------- Process peaks
                next_entry = 1;
                
                if and(obj.show_recursive_peaks, ...
                        current_recursion ~= obj.prn_level)
                    % peak_times = current_struct.extended_peaks_times;
                    peak_times = current_struct.paired_forward_peaks_times;
                    for f = 1:length(peak_times)
                        % process each peak
                        text_pulse_struct(next_entry).event_char = ...
                            obj.PULSE_PEAK_CHAR; 
                        
                        % Define sturcture properties
                        text_pulse_struct(next_entry).recursion_level = ...
                            num_recursions;
                        text_pulse_struct(next_entry).event_type = ...
                            obj.EVENT_TYPES{obj.PULSE_PEAK_VAL};
                        text_pulse_struct(next_entry).event_t = peak_times(f);
                        text_pulse_struct(next_entry).sort_time = ...
                            double(double(peak_times(f)) - offset...
                            - 1*e);
                        text_pulse_struct(next_entry).secretion_rate = NaN;
                        text_pulse_struct(next_entry).cleareance_rate = NaN;
                        text_pulse_struct(next_entry).interpulse_interval = NaN;
                        text_pulse_struct(next_entry).associated_event_types = {};
                        text_pulse_struct(next_entry).associated_event_times = [];
                        
                        % prepare for next entry
                        next_entry = next_entry+ 1;
                    end
                end
                %------------------------------ Process Pulse Start and End
                % valley_times = current_struct.extended_valley_times;
                valley_times = current_struct.paired_forward_valleys_times;
                for s = 1: length(valley_times)-1
                    % Add start segment
                    text_pulse_struct(next_entry).event_char = ...
                        obj.PULSE_START_CHAR;
                    text_pulse_struct(next_entry).recursion_level = ...
                        num_recursions;
                    text_pulse_struct(next_entry).event_type = ...
                        obj.EVENT_TYPES{obj.PULSE_START_VAL};
                    text_pulse_struct(next_entry).event_t = valley_times(s);
                    text_pulse_struct(next_entry).sort_time = ...
                        double(double(valley_times(s)) + offset...
                            + 2.0*e);
                    text_pulse_struct(next_entry).secretion_rate = NaN;
                    text_pulse_struct(next_entry).cleareance_rate = NaN;
                    text_pulse_struct(next_entry).interpulse_interval = NaN;
                    text_pulse_struct(next_entry).associated_event_types = {};
                    text_pulse_struct(next_entry).associated_event_times = [];
                    next_entry = next_entry + 1;
                    
                    
                    % Add end segment
                    text_pulse_struct(next_entry).event_char = ...
                        obj.PULSE_END_CHAR;
                    text_pulse_struct(next_entry).recursion_level = ...
                        num_recursions;
                    text_pulse_struct(next_entry).event_type = ...
                        obj.EVENT_TYPES{obj.PULSE_END_VAL};
                    text_pulse_struct(next_entry).event_t = valley_times(s+1);
                    text_pulse_struct(next_entry).sort_time = ...
                        double(double(valley_times(s+1)) - offset...
                            - 2*e);
                    text_pulse_struct(next_entry).secretion_rate = NaN;
                    text_pulse_struct(next_entry).cleareance_rate = NaN;
                    text_pulse_struct(next_entry).interpulse_interval = NaN;
                    text_pulse_struct(next_entry).associated_event_types = {};
                    text_pulse_struct(next_entry).associated_event_times = [];
                    next_entry = next_entry + 1;
                end
                
                % Store results to allow for printing of intermediate steps
                text_pulse_struct1 = text_pulse_struct;
                text_pulse_struct1 = ...
                    sort_struct(obj, text_pulse_struct1, 'sort_time');
                   
                % Continue recursion if necessary
                return_struct_vallid = 0;
                if obj.PRN_LEVEL > current_recursion
                    % Process structure from end to start
                    [recurse_text_pulse_struct return_struct_vallid ] = ...
                        process_recursion_array...
                            (obj, recurrsion_array(1:end-1));                    
 
                    % Merge recurse values
                    if return_struct_vallid
                        % Merge stuct
                        text_pulse_struct = merge_sort_struct (obj, ...
                            text_pulse_struct1, recurse_text_pulse_struct,...
                            'sort_time' );
                    end
                end
             
                %---------------------------------- Echo results to console
                if and(obj.or_list(LOCAL_DEBUG_FLAG, ...
                        obj.GLOBAL_DEBUG_FLAG,...
                        obj.show_recursion_results), ...
                        obj.prn_level == 1)
                    % echo text summary and time for first level only
                    obj.prn_recursion_summary(text_pulse_struct1, ...
                        current_recursion);
                    % Echo results to console
                elseif and(obj.or_list(LOCAL_DEBUG_FLAG, ...
                        obj.GLOBAL_DEBUG_FLAG,...
                        obj.show_recursion_results),...
                        ~return_struct_vallid)
                    % echo text summary and time for first level and
                    % recursion return
                    obj.prn_recursion_summary(text_pulse_struct1, ...
                        current_recursion);
                elseif and(obj.or_list(LOCAL_DEBUG_FLAG, ...
                        obj.GLOBAL_DEBUG_FLAG,...
                        obj.show_recursion_results,...
                        ~obj.show_intermediate_recursion_results),...
                        return_struct_vallid)
                    % echo text summary and time for first level,
                    % recursion return, and merged value
                    obj.prn_recursion_summary(text_pulse_struct, ...
                        current_recursion);
                elseif and(obj.or_list(LOCAL_DEBUG_FLAG, ...
                        obj.GLOBAL_DEBUG_FLAG,...
                        obj.show_recursion_results,...
                        obj.show_intermediate_recursion_results),...
                        return_struct_vallid)
                    % echo text summary and time for first level,
                    % recursion return, and merged value
                    obj.prn_recursion_summary(text_pulse_struct1, ...
                        current_recursion);
                    obj.prn_recursion_summary(text_pulse_struct, ...
                        current_recursion, recurse_text_pulse_struct);
                end
                
                % Set flag to vallid
                vallid = 1;
            end
            
        end
        %------------------------------------------------------- get string
        function pulse_string = get_string(obj, struct1, char_field)
            %get_string get string from structure
            %
            
            % text_pulse_str
            for s = 1:length(struct1)
                pulse_string(s) = ...
                    eval(sprintf('struct1(%d).%s',s,char_field));
            end
            
        end
        %------------------------------------------------ merge_sort_struct
        function [ struct3 ] = merge_sort_struct...
                (obj, struct1, struct2, sort_field )
            %merge_sort_struct uses private functions to merge and sort
            %stucture
            %
            
            % Function constants
            LOCAL_DEBUG_FLAG = 0;
            
            % Determine struct size
            struct3 = merge_struct(obj, struct1, struct2 );
            struct3 = sort_struct( obj, struct3, sort_field );
        end
        %----------------------------------------------------- merge_struct
        function struct3 = merge_struct(obj, struct1, struct2 );
            %merge_struct function merges the struct array in the order given
            %
            
            % Function constants
            LOCAL_DEBUG_FLAG = 0;
            
            % Determine struct size
            struct1_size = length(struct1);
            struct2_size = length(struct2);
            struct_fields = fieldnames(struct2);
            struct3 = struct1;
            for e = 1:struct2_size
                % add each field and value dynamically, assume defaults 
                % for struct1
                for f = 1:length(struct_fields);
                    next_entry = struct1_size + e;
                    field = struct_fields{f};
                    field_cmd = sprintf('struct3(%d).%s = struct2(%d).%s;',...
                        next_entry, field, e, field);
                    eval(field_cmd);
                end
            end
        end
        %------------------------------------------------------ sort_struct
        function struct2 = sort_struct( obj, struct1, sort_field )
            %sort_struct array entries are sorted according to values in
            % selected field
            
            % Function constant
            LOCAL_DEBUG_FLAG = 0;
            
            % Echo input during debug
             if LOCAL_DEBUG_FLAG == 1
                struct1
                sort_field
            end
            
            % Get sort field values
            get_values_f = ...
                @(x)eval(sprintf('struct1(%d).%s(1)',x,sort_field));
            values = arrayfun(get_values_f, [1:length(struct1)]);
            [sorted_values sort_permutation] = sort(values);   
            struct2 = struct1(sort_permutation);
        end
        %------------------------------------------------- char_time_offset
        function offset = char_time_offset(obj, r)
            %char_time_offset the recurrsion level 
            
            % Function constant
            LOCAL_DEBUG_FLAG = 0;
            
            scale = 10^r;
            offset = sum(10.^[1:1:r-1]*obj.START_RECURSION_VALUE/scale);
            offset = 0;
            
            if LOCAL_DEBUG_FLAG == 1
                fprintf('---------------------------- char_time_offset\n');
                scale
                start_value
                offset
                fprintf('---------------------------------------------\n');
            end
        end
        %---------------------------------------------------------- epsilon
        function e = epsilon(obj, r)
            %char_time_offset the recurrsion level 
            
            % Function constant
            LOCAL_DEBUG_FLAG = 0;
            
            % The organized
            e = obj.TIME_SORT_EPSILON/10^(obj.num_recursions - r +1);

            if LOCAL_DEBUG_FLAG == 1
                fprintf('------------------------------------- epsilon\n');
                disp(e);
                fprintf('---------------------------------------------\n');
            end
        end
        %-------------------------------------------- prn_recursion_summary
        function vargout = prn_recursion_summary(varargin)
            
            % prn_recursion_summary is prints results from the structures
            % used to maintain information during and between recursions.
            %
            
            if nargin == 4
                % print out two rows of information
                obj = varargin{1};
                text_pulse_struct = varargin{2};
                current_recursion_level = varargin{3};
                recursed_text_pulse_struct = varargin{4};
            elseif nargin == 3
                % print out text_pulse_struct information
                obj = varargin{1};
                text_pulse_struct = varargin{2};
                current_recursion_level = varargin{3};
            else
                % number of arguments not handles
            end
            % Function constant
            LOCAL_DEBUG_FLAG = 0;
            
            % Echo input summary to console
            if LOCAL_DEBUG_FLAG
                if nargin == 4
                    fprintf('recursed_text_pulse_struct');
                    disp(recursed_text_pulse_struct)
                end
                
                if nargin >= 3
                    fprintf('text_pulse_struct');
                    disp(text_pulse_struct)
                    fprintf('current_recursion_level');
                    disp(current_recursion_level)
                end
            end
            
            
            % Echo results to console
            fprintf('\nRecursion Summary - %d\n',current_recursion_level)
            
            % Echo recurse text pulse struct
            if nargin == 4
                fprintf('--------------------------------------------------------------\n')
                get_sort_times_F = ...
                    @(x)eval(sprintf('recursed_text_pulse_struct(%d).%s',x,'event_char'));
                disp(arrayfun(get_sort_times_F, ...
                    [1:length(recursed_text_pulse_struct)]));
                
                get_sort_times_F = ...
                    @(x)eval(sprintf('recursed_text_pulse_struct(%d).%s',x,'sort_time'));
                obj.display_vector(arrayfun(get_sort_times_F, ...
                    [1:length(recursed_text_pulse_struct)]),obj.prn_precision);
                
                get_sort_times_F = ...
                    @(x)eval(sprintf('recursed_text_pulse_struct(%d).%s',x,'event_t'));
                obj.display_vector(arrayfun(get_sort_times_F, ...
                    [1:length(recursed_text_pulse_struct)]),obj.prn_precision);
            end
            
            % echo text pulse structure
            if nargin >= 3
                fprintf('--------------------------------------------------------------\n')
                get_sort_times_F = ...
                    @(x)eval(sprintf('text_pulse_struct(%d).%s',x,'event_char'));
                disp(arrayfun(get_sort_times_F, ...
                    [1:length(text_pulse_struct)]));
                
                get_sort_times_F = ...
                    @(x)eval(sprintf('text_pulse_struct(%d).%s',x,'sort_time'));
                obj.display_vector(arrayfun(get_sort_times_F, ...
                    [1:length(text_pulse_struct)]),obj.prn_precision);
                
                get_sort_times_F = ...
                    @(x)eval(sprintf('text_pulse_struct(%d).%s',x,'event_t'));
                obj.display_vector(arrayfun(get_sort_times_F, ...
                    [1:length(text_pulse_struct)]),obj.prn_precision);
            end
            
            % Prepare output
            if nargout == 0
                vargout = {};
            elseif nargout == 1
                % Dummy uotput so that function can be use in cell array
                vargout = {1};
            end
        end
    end
    %------------------------------------------------------- Static Methods
    methods(Static)
        %---------------------------------------------------------- or_list
        function or_val = or_list(varargin)
        %or_list takes the or of all the arguments
        %
        
            % Apply 'or' sequentially
            or_val = varargin{1};
            for e = 2:length(varargin)
                or_val = or(or_val, varargin{e});
            end
        end
        %--------------------------------------------------------- and_list
        function and_val = and_list(varargin)
        %and_list Returns the and of all the arguments
        %
        
            % Apply 'and' sequentially
            and_val = varargin{1};
            for e = 2:length(varargin)
                and_val = and(and_val, varargin{e});
            end
        end
        %----------------------------------------------- display_vector_int
        function display_vector_int(data_vec)
        %
        % display_vector_int
        %
        % Input:
        %   data_vec - array of integers
        % 
        % Output:
        %   Tab delimited list at the console.
        %
        %
        
        
            % Write array to console
            fprintf('(\t%d',data_vec(1))
            for i = 2:length(data_vec)
                fprintf(' \t%d',data_vec(i))
            end
            fprintf(')\n');
        end
        %--------------------------------------------------- display_vector
        function display_vector(varargin)
        %
        % display_vector
        %
        % Input:
        %   data_vec - array of floats
        %   precision - number of digits following the decimal
        %   field_length  - number characters allocated for entry
        % 
            % Default Values
            precision = 2;
            field_length = 10;
            
            % Process input and override defaults if necessary
            if nargin == 1
                data_vec = varargin{1};
            elseif nargin == 2
                data_vec = varargin{1};
                precision = varargin{2};
            elseif nargin == 3
                data_vec = varargin{1};
                precision = varargin{2};
                field_length = varargin{3};
            else
                error('display_vector(data_vec), display_vector(data_vec, precision), display_vector(data_vec, precision, field_length)');
            end
            
            % Echo array to console
            if length(data_vec) >= 1
                % Generate output string based on 
                start_command_str = sprintf('fprintf(''(\t%%.%df'',data_vec(1))', ...
                    precision);
                loop_command_str = sprintf('fprintf('' \t%%.%df'',data_vec(i))', ...
                    precision);
            
                % Write array to console
                eval(start_command_str);
                for i = 2:length(data_vec)
                    eval(loop_command_str);
                end
                fprintf(')\n');
            else
                % Print brackets for an empty array
                fprintf('( )\n');
            end
        end 
    end
end
